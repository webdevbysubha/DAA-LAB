# DAA LAB

This repository contains implementations and explanations for various **Design and Analysis of Algorithms (DAA)** topics covered in the lab. Below is the list of algorithms and problems included:

---

## Table of Contents
1. [Quick Sort](#quick-sort)
2. [Merge Sort](#merge-sort)
3. [Matrix Chain Multiplication](#matrix-chain-multiplication)
4. [Travelling Salesperson Problem](#travelling-salesperson-problem)
5. [Bellman-Ford Shortest Path](#bellman-ford-shortest-path)
6. [Fractional Knapsack](#fractional-knapsack)
7. [Job Sequence Problem](#job-sequence-problem)
8. [N-Queen Problem](#n-queen-problem)
9. [Graph Coloring](#graph-coloring)
10. [Kruskal's Algorithm](#kruskals-algorithm)
11. [Prim's Algorithm](#prims-algorithm)
12. [Breadth-First Search (BFS) and Depth-First Search (DFS)](#bfs-and-dfs)

---

## 1. Quick Sort
Quick Sort is a highly efficient sorting algorithm that uses a divide-and-conquer approach to sort elements.

- **Time Complexity**: O(n log n) on average
- **Space Complexity**: O(log n)

[Learn More](https://en.wikipedia.org/wiki/Quicksort)

---

## 2. Merge Sort
Merge Sort is a stable, comparison-based sorting technique using a divide-and-conquer approach.

- **Time Complexity**: O(n log n)
- **Space Complexity**: O(n)

[Learn More](https://en.wikipedia.org/wiki/Merge_sort)

---

## 3. Matrix Chain Multiplication
Matrix Chain Multiplication is a dynamic programming algorithm used to find the most efficient way to multiply matrices.

- **Time Complexity**: O(n^3)
- **Space Complexity**: O(n^2)

[Learn More](https://en.wikipedia.org/wiki/Matrix_chain_multiplication)

---

## 4. Travelling Salesperson Problem (TSP)
TSP is a classic optimization problem where the goal is to find the shortest possible route that visits each city exactly once and returns to the origin city.

- **Time Complexity**: O(n^2 * 2^n) using dynamic programming
- **Space Complexity**: O(n * 2^n)

[Learn More](https://en.wikipedia.org/wiki/Travelling_salesman_problem)

---

## 5. Bellman-Ford Shortest Path
Bellman-Ford is an algorithm used to compute the shortest paths from a single source vertex to all other vertices in a weighted graph, even with negative weight edges.

- **Time Complexity**: O(VE)
- **Space Complexity**: O(V)

[Learn More](https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm)

---

## 6. Fractional Knapsack
The Fractional Knapsack problem is an optimization problem where fractions of items can be taken to maximize the total value.

- **Time Complexity**: O(n log n)
- **Space Complexity**: O(1)

[Learn More](https://en.wikipedia.org/wiki/Knapsack_problem#Fractional_knapsack_problem)

---

## 7. Job Sequence Problem
This problem is solved using a greedy algorithm to maximize profit by scheduling jobs within their deadlines.

- **Time Complexity**: O(n log n)
- **Space Complexity**: O(n)

[Learn More](https://en.wikipedia.org/wiki/Job_scheduling_problem)

---

## 8. N-Queen Problem
The N-Queen problem is a classic backtracking algorithm where the goal is to place N queens on an NÃ—N chessboard such that no two queens threaten each other.

- **Time Complexity**: O(N!)
- **Space Complexity**: O(N)

[Learn More](https://en.wikipedia.org/wiki/Eight_queens_puzzle)

---

## 9. Graph Coloring
Graph Coloring is the problem of assigning colors to the vertices of a graph so that no two adjacent vertices share the same color.

- **Time Complexity**: O(V+E)
- **Space Complexity**: O(V)

[Learn More](https://en.wikipedia.org/wiki/Graph_coloring)

---

## 10. Kruskal's Algorithm
Kruskalâ€™s algorithm is a greedy algorithm used to find a minimum spanning tree for a connected weighted graph.

- **Time Complexity**: O(E log E)
- **Space Complexity**: O(V)

[Learn More](https://en.wikipedia.org/wiki/Kruskal%27s_algorithm)

---

## 11. Prim's Algorithm
Primâ€™s algorithm is another greedy algorithm used to find the minimum spanning tree of a graph.

- **Time Complexity**: O(E log V)
- **Space Complexity**: O(V)

[Learn More](https://en.wikipedia.org/wiki/Prim%27s_algorithm)

---

## 12. Breadth-First Search (BFS) and Depth-First Search (DFS)
BFS and DFS are fundamental graph traversal algorithms used in various applications.

- **BFS Time Complexity**: O(V + E)
- **DFS Time Complexity**: O(V + E)
- **Space Complexity**: O(V)

[Learn More](https://en.wikipedia.org/wiki/Breadth-first_search) | [DFS](https://en.wikipedia.org/wiki/Depth-first_search)

---

## Contributions
Feel free to fork the repository and contribute by submitting pull requests.

---

## License
This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

---

---

## ðŸ‘¤ Author

~ **Subha Mondal**

(Feel free to reach out if you have any questions or suggestions!)

---

